var TestControl = require('./test_control').TestControl
  , timers = require('timers');

// Set processor, setImmediate if 0.10 otherwise nextTick
// var processor = timers.setImmediate ? timers.setImmediate : process.nextTick;
var processor = process.nextTick;

//
// Wraps a test suite
//
var TestSuite = function(runner, formatter, configuration, name, files, options) {
  this.runner = runner;
  this.formatter = formatter;
  this.configuration = configuration;
  this.name = name;
  this.files = files.filter(function(file) { return typeof file == 'string' });
  this.options = options ? options : {};
  // Statistics
  this.test_controls = [];

  this.execute_parallel = function(config_name, options, callback) {
    var self = this;
    var buckets = [];
    var tests = [];
    var number_of_contexts = options.number_of_contexts ? options.number_of_contexts : 1;
    var number_of_contexts_left = number_of_contexts;

    // Set up the context
    for(var i = 0; i < number_of_contexts; i++) buckets[i] = [];
    for(var i = 0; i < number_of_contexts; i++) tests[i] = [];

    // Start all the configurations
    this.configuration.createAndStart(config_name
      , { number_of_contexts: number_of_contexts, 
          after_configuration_start: runner.after_configuration_start }, function(err, configurations) {
      // If we have a file level, split files into buckets and run 
      // concurrently
      var index = 0;

      // Handle tests done
      var done = function(err) {
        number_of_contexts_left = number_of_contexts_left - 1;

        if(number_of_contexts_left == 0) {
          callback();
        }
      }

      // If we have scheduler hints otherwise
      if(self.options.schedulerHints != null) {
        var test_hash = {};

        for(var i = 0; i < self.files.length; i++) {
          // Read the test file in
          var test = require(process.cwd() + self.files[i]);

          // Create a hash so we can correctly reorder the tests
          for(var name in test) {
            if(options.test && options.test == name) {
              test_hash[self.files[i] + name] = {test:test, name:name, file:self.files[i]};
            } else if(options.test == null) {
              test_hash[self.files[i] + name] = {test:test, name:name, file:self.files[i]};              
            }
          }
        }

        // Guess total times for each context
        var calculated_times = [];
        for(var j = 0; j < tests.length; j++) calculated_times[j] = {index: j, time: 0};

        // Let's schedule from the top of the hints
        for(var j = 0; j < self.options.schedulerHints.length; j++) {
          console.dir(self.options)
          var hint = self.options.schedulerHints[j];
          // Hint references existing file
          if(test_hash[hint.file + hint.test]) {
            // Push to the queue with least cumulative time
            tests[calculated_times[0].index].push(test_hash[hint.file + hint.test]);
            calculated_times[0].time += hint.time;
            // Sort according to minimum time (minimum execution time in slot 0)
            calculated_times = calculated_times.sort(function(a, b) { return a.time - b.time});
            delete test_hash[hint.file + hint.test];
          }
        }

        // Do we have any tests not covered by the hints
        for(name in test_hash) {
          tests[index].push(test_hash[name]);
          index = (index + 1) % number_of_contexts;
        }
      } else {
        // Let's build the test objects that will run in parallel
        for(var i = 0; i < self.files.length; i++) {
          // Read the test file in
          var test = require(process.cwd() + self.files[i]);
          
          // Distribute the tests
          for(var name in test) {
            // If not excluded by the filter run it
            if(runner.filter_function == null 
              || (typeof runner.filter_function == 'function' && runner.filter_function(test[name]))) {
                if(options.test && options.test == name) {
                  tests[index].push({test:test, name:name, file: self.files[i]});
                  index = (index + 1) % number_of_contexts;
                } else if(options.test == null) {
                  tests[index].push({test:test, name:name, file: self.files[i]});
                  index = (index + 1) % number_of_contexts;              
                }
            }
          }
        }
      }

      // Sweet now run the tests serially
      for(var i = 0; i < number_of_contexts; i++) {
        process_parallel_tests_serially(self, configurations[i], tests[i], options, done);
      }
    });
  }

  this.execute = function(config_name, options, callback) {
    this.execute_parallel(config_name, options, callback);
  }  
}

var process_parallel_tests_serially = function(self, configuration, tests, options, callback) {
  var test = tests.pop();

  // Let's run the test
  // Done function
  var done_function = function(_test_control) {
    return function() {
      // Set test end time
      _test_control.end_time = new Date();
      // Execute the tear down function
      configuration.teardown(function() {
        // If we have no assertion errors print test name
        if(_test_control.number_of_failed_assertions == 0) {
          console.log('✔ ' + _test_control.name);
        } else {
          console.log(self.formatter.error('✖ ' + _test_control.name));
          // Assertions
          _test_control.assertions.forEach(function (a) {
            console.log('Assertion Message: ' + self.formatter.assertion_message(a.message));
            console.log(a.stack + '\n');
          });
        }

        // Emit the test statistics
        processor(function() {
          self.runner.emit("test_done", _test_control);
        })

        // If we have more tests execute them
        if(tests.length > 0) {
          processor(function() {
            process_parallel_tests_serially(self, configuration, tests, options, callback);
          })
        } else {
          callback(null, []);
        }
      });
    }
  }

  // Return
  if(test == null) return callback(null, []);
  // Test control
  console.log("STARTING 0 :: " + tests.length + " :: " + test.name)
  var test_control = new TestControl(configuration, test.file, test.name);
  test_control.done = done_function(test_control); 
  // Execute configuration setup
  configuration.setup(function() {
    processor(function() {
      try {
        // Set test start time
        test_control.start_time = new Date();
        // Execute the test
        if(typeof test.test[test.name] == 'function') {
          test.test[test.name].apply(test.test, [configuration, test_control]);
        } else {
          test.test[test.name].test.apply(test.test, [configuration, test_control]);
        }        
      } catch(err) {
        console.dir(err)
        processor(function() {
          throw err;
        });
      }
    });
  });
}

exports.TestSuite = TestSuite;